## Java Version
1. Java SE (Java Standard Edition) - 클라이언트 지향의 기본적인 환경
2. Java EE (Java Enterprise Edition) - 큰 규모를 가진 네트워크 애플리케이션, 웹 기반 애플리케이션 개발을 위한 환경
3. Java ME (Java Micro Edition) - 메모리가 작은 값으로 제한된 기기들의 개발을 위한 환경

## Java의 특징
1. OS에 독립적 - 자바 응용프로그램은 오로지 JVM과 통신하고, JVM이 OS가 이해할 수 있도록 전달받은 명령을 변환하여 전달
2. 객체 지향 언어 - 상속, 캡슐화, 다형성이 잘 적용된 순수한 언어
3. 자동 메모리 관리(GC) - 자동으로 메모리를 관리해줌으로서 메모리 관리에 신경쓰지 않아도 됨
4. 네트워크와 분산처리 지원
5. 멀티쓰레드 지원
6. 동적 로딩 지원 - 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있음 / 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 됨

### 단점
1. JVM 위에서 동작하기 때문에 속도가 느림 - 바이트코드를 하드웨어의 기계어로 바로 변환해주는 JIT(Just-In-Time) 컴파일러의 도입으로 개선

## Java에서 제공하는 원시 타입
1. 정수형 - byte, short, int, long
2. 실수형 - float, double
3. 문자형 - char
4. 논리형 - boolean

## Overriding VS Overloading
- Overriding = 상위 클래스에 있는 메소드를 하위 클래스에서 재정의하는 것
- Overloading = 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것

## 객체 지향 프로그래밍이란
- 실생활에서 사용하는 모든 것을 '객체'라 하며, 프로그램 구현에 필요한 객체를 파악하고 객체들간의 상호작용을 통해 프고르매을 만드는 것

## 객체 지향 프로그래밍 특징
1. 추상화 : 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념으로 다루는 것
2. 캡슐화 : 정보은닉 / 높은 응집도와 낮은 결합도를 유지하여 유연함과 유지보수성 증가
3. 상속 : 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정
4. 다형성 : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 것

## 클래스와 객체
- 클래스 : 객체를 만들어내기 위한 설계도 혹은 틀, 객체 생성에 사용
- 객체 : 현실세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집
- 인스턴스 : 객체에 메모리가 할당되어 실제로 활용되는 실체

## 생성자
- 생성자 : 클래스와 같은 이름의 메소드, 객체가 생성될 때 호출되는 메소드

## 추상 클래스와 인터페이스
- 추상 클래스 : 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우
- 인터페이스 : 모든 메소드가 추상 메소드로만 이루어져 있는 경우

### 공통점
- new 연산자로 인스턴스 생성 불가능
- 사용하기 위해선 하위 클래스에서 확장/구현 해야함
### 차이점
- 추상 클래스 : 다중 상속 불가능 / 인터페이스 : 다중 상속 가능
- 추상 클래스 : 상속받는 클래스들의 공통 로직을 추상화시키고, 기능 확장을 위해 사용
- 인터페이스 : 구현하는 모든 클래스에 대해 특정 메소드가 반드시 존재하도록 강제함

## Wrapper Class / Boxing, UnBoxing
- 기본 자료형(Primitive data type)에 대한 객체 표현 (기본 타입의 데이터를 객체로 표현해야 할 때 객체로 다루기 위해 사용하는 클래스)
- Boxing : 기본 자료형 -> Wrapper class로 변환
- UnBoxing : Wrapper class -> 기본 자료형으로 변환
- Byte / Character / Integer / Float / Double / Boolean / Long / Short

## 객체 지향 설계 원칙
1. SRP (단일-책임 원칙) - 한 클래스는 하나의 책임만 가져야 함
2. OCP (개방-폐쇄 원칙) - 확장에는 열려있고, 수정에는 닫혀있어야 함
3. LSP (리스코프 치환 원칙) - 하위 타입은 항상 상위 타입을 대체할 수 있어야 함
4. ISP (인터페이스 분리 원칙) - 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다
5. DIP (의존관계 역전 원칙) - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라

## 불변 객체란
- 객체 생성 이후 내부의 상태가 변하지 않는 객체
- 원시 타입인 경우 final 키워드를 통해 만들 수 있고 참조 타입일 경우엔 추가 작업 필요

## 싱글톤 패턴
- 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우 / 동일 인스턴스를 자주 생성해야 하는 경우에 사용 (메모리 낭비 방지)
- 대표적으로 Spring Bean (스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프 / 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리)
- 스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공 (프로토타입 빈, @Scope("prototype"))

## 자바 메모리 영역
- Method / Stack / Heap 으로 구분되고, 데이터 타입에 따라 할당
- Method 영역 : 전역변수와 static 변수를 저장하며, Method 영역은 프로그램 시작부터 종료까지 메모리에 남아있음
- Stack 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리 해제, LIFO 구조를 가지고 변수에 새로운 데이터가 할당되면 이전 데이터 삭제
- Heap 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장, GC에 의해 메모리 관리

### 각 메모리 영역 할당 시점
- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 컴파일 타임 시 할당
- Heap 영역 : 런타임시 할당
- 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정
- 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때

## static
- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용 가능
- 인스턴스 생성 없이 바로 사용 가능
- 모든 객체가 메모리를 공유한다는 특징, GC 관리 영역 밖에 있기 때문에 프로그램 종료까지 메모리에 값이 유지된 채로 존재

### static 사용 이유
- '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있음
- 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용

## 접근 제한자 (Access Modifier)
- public : 접근 제한 없음 (같은 프로젝트 내 어디서든 사용 가능)
- protected : 해당 패키지 내, 다른 패키지에서 상속받아 자식 클래스에서 접근 가능
- default : 해당 패키지 내에서만 접근 가능
- private : 해당 클레스에서만 접근 가능

## 클래스 멤버 변수 초기화 순서
1. static 변수 선언부 : 클래스가 로드될 때 변수가 제일 먼저 초기화
2. 필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화
3. 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking (thread-safe 영역)

## 컬렉션 프레임워크
- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
- List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재

![컬렉션 프레임워크](https://github.com/Meow-Lee/Interview-Information/assets/67636286/e891a241-19fc-41cc-8856-7bdb99de6ad8)

- List : 순서가 있는 데이터의 집합이며, 데이터의 중복 허용
- Set : 순서가 없는 데이터의 집합이며, 데이터의 중복 허용 X
- Map : 키와 값이 한 쌍으로 이루어져 있고, 키를 기준으로 중복 허용 X, 순서 없음

### Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할 것인가
- hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지 보고 해시코드 값이 다르다면 다른 객체로 판단
- 해시코드 값이 같다면 equals() 메소드를 오버라이딩하여 다시 비교
- 두 값이 모두 맞다면 중복 객체

## Error VS Exception
- Error : 실행 중 일어날 수 있는 치명적 오류 / 컴파일 시점에 체크 X / 오류가 발생하면 프로그램 비정상 종료
- Exception : 비교적 경미한 오류 / try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있음

### CheckedException VS UncheckedException
- CheckedException : 실행 전 예측 가능한 예외 / 반드시 예외 처리 / IOException, ClassNotFoundException
- UncheckedException : 실행한 후에 알 수 있는 예외

## new String() VS 리터럴 ("")
- new String() : new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장
- "" : Heap 안에 있는 String Constant Pool 영역에 저장

## String VS StringBuffer VS StringBuilder
- String : 불변의 속성 / StringBuffer, StringBuilder : 가변의 속성
- StringBuffer : 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용
- StringBuilder : 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용

## 제네릭
- 데이터 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미
- 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지 가능

## final / finally / finalize 차이
- final : 클래스, 메소드, 변수, 인자 선언 시 사용, 한 번만 할당하고 싶을 때 사용
- finally : try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되므로 마무리 작업이 존재하는 경우 작성
- finalize : Object 클래스에 정의되어 있는 메소드, GC에 의해 호출되는 메소드로 절대 호출하면 안되는 메소드

## Synchronized
- 여러 개의 Thread가 한 개의 자원을 사용하고자 할 때, 현제 데이터를 사용하고 있는 Thread를 제외한 나머지는 데이터에 접근 불가
- 데이터의 thread-safe를 위해 자바에서 Synchronized 키워드를 제공해 멀티 thread 환경에서 thread 간 동기화를 시켜 thread-safe를 보장
- 변수와 메소드에 사용해 동기화 할 수 있지만, 남발하면 프로그램의 성능 저하를 일으킬 수 있음

## Inner Class (내부 클래스)의 장점
- 외부 클래스의 멤버에 쉽게 접근 가능
- 서로 관련있는 클래스를 논리적으로 묶어서 표현, 캡슐화 증가, 코드의 복잡성을 낮춤
- 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성 증가

## Reflection (리플렉션)
- 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API
- 코드 작성 시점에서 어떤 타입의 클래스를 사용할 지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용

## Optional API
- NPE(NullPointerException)을 피하려면 null 여부 검사는 필연적
- 따라서 Optional<T>를 활용해 null로 인한 예외를 피하고, Optional 클래스의 메소드를 통해 null을 컨트롤 가능

## 직렬화 (Serialize)
- 시스템 내부에서 사용되는 객체 또는 데이터를 외부 시스템에서 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술
- 역직렬화 : 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정
- 즉, JVM의 메모리에 있는 객체 데이터를 바이트 형태로 변환하는 기술

## Reference
https://dev-coco.tistory.com/153
