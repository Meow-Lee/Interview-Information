## Java Version
1. Java SE (Java Standard Edition) - 클라이언트 지향의 기본적인 환경
2. Java EE (Java Enterprise Edition) - 큰 규모를 가진 네트워크 애플리케이션, 웹 기반 애플리케이션 개발을 위한 환경
3. Java ME (Java Micro Edition) - 메모리가 작은 값으로 제한된 기기들의 개발을 위한 환경

## Java의 특징
1. OS에 독립적 - 자바 응용프로그램은 오로지 JVM과 통신하고, JVM이 OS가 이해할 수 있도록 전달받은 명령을 변환하여 전달
2. 객체 지향 언어 - 상속, 캡슐화, 다형성이 잘 적용된 순수한 언어
3. 자동 메모리 관리(GC) - 자동으로 메모리를 관리해줌으로서 메모리 관리에 신경쓰지 않아도 됨
4. 네트워크와 분산처리 지원
5. 멀티쓰레드 지원
6. 동적 로딩 지원 - 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있음 / 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 됨

### 단점
1. JVM 위에서 동작하기 때문에 속도가 느림 - 바이트코드를 하드웨어의 기계어로 바로 변환해주는 JIT(Just-In-Time) 컴파일러의 도입으로 개선

## Java에서 제공하는 원시 타입
1. 정수형 - byte, short, int, long
2. 실수형 - float, double
3. 문자형 - char
4. 논리형 - boolean

## Overriding VS Overloading
- Overriding = 상위 클래스에 있는 메소드를 하위 클래스에서 재정의하는 것
- Overloading = 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것

## 객체 지향 프로그래밍이란
- 실생활에서 사용하는 모든 것을 '객체'라 하며, 프로그램 구현에 필요한 객체를 파악하고 객체들간의 상호작용을 통해 프고르매을 만드는 것

## 클래스와 객체
- 클래스 : 객체를 만들어내기 위한 설계도 혹은 틀, 객체 생성에 사용
- 객체 : 설계도(클래스)를 기반으로 생성, 자신의 고유 이름과 상태, 행동을 가짐
- 인스턴스 : 객체에 메모리가 할당되어 실제로 활용되는 실체

## 생성자
- 생성자 : 클래스와 같은 이름의 메소드, 객체가 생성될 때 호출되는 메소드

## 추상 클래스와 인터페이스
- 추상 클래스 : 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우
- 인터페이스 : 모든 메소드가 추상 메소드로만 이루어져 있는 경우

### 공통점
- new 연산자로 인스턴스 생성 불가능
- 사용하기 위해선 하위 클래스에서 확장/구현 해야함
### 차이점
- 추상 클래스 : 다중 상속 불가능 / 인터페이스 : 다중 상속 가능
- 추상 클래스 : 상속받는 클래스들의 공통 로직을 추상화시키고, 기능 확장을 위해 사용
- 인터페이스 : 구현하는 모든 클래스에 대해 특정 메소드가 반드시 존재하도록 강제함

## Wrapper Class / Boxing, UnBoxing
- 기본 자료형(Primitive data type)에 대한 객체 표현 (기본 타입의 데이터를 객체로 표현해야 할 때 객체로 다루기 위해 사용하는 클래스)
- Boxing : 기본 자료형 -> Wrapper class로 변환
- UnBoxing : Wrapper class -> 기본 자료형으로 변환
- Byte / Character / Integer / Float / Double / Boolean / Long / Short

## 객체 지향 설계 원칙
1. SRP (단일-책임 원칙) - 한 클래스는 하나의 책임만 가져야 함
2. OCP (개방-폐쇄 원칙) - 확장에는 열려있고, 수정에는 닫혀있어야 함
3. LSP (리스코프 치환 원칙) - 하위 타입은 항상 상위 타입을 대체할 수 있어야 함
4. ISP (인터페이스 분리 원칙) - 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다
5. DIP (의존관계 역전 원칙) - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라

## 불변 객체란
- 객체 생성 이후 내부의 상태가 변하지 않는 객체
- 원시 타입인 경우 final 키워드를 통해 만들 수 있고 참조 타입일 경우엔 추가 작업 필요

## 싱글톤 패턴
- 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우 / 동일 인스턴스를 자주 생성해야 하는 경우에 사용 (메모리 낭비 방지)
- 대표적으로 Spring Bean (스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프 / 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리)
- 스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공 (프로토타입 빈, @Scope("prototype"))

## 자바 메모리 영역
- Method / Stack / Heap 으로 구분되고, 데이터 타입에 따라 할당
- Method 영역 : 전역변수와 static 변수를 저장하며, Method 영역은 프로그램 시작부터 종료까지 메모리에 남아있음
- Stack 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리 해제, LIFO 구조를 가지고 변수에 새로운 데이터가 할당되면 이전 데이터 삭제
- Heap 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장, GC에 의해 메모리 관리

### 각 메모리 영역 할당 시점
- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 컴파일 타임 시 할당
- Heap 영역 : 런타임시 할당
- 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정
- 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때

## static
- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용 가능
- 인스턴스 생성 없이 바로 사용 가능
- 모든 객체가 메모리를 공유한다는 특징, GC 관리 영역 밖에 있기 때문에 프로그램 종료까지 메모리에 값이 유지된 채로 존재

### static 사용 이유
- '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있음
- 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용

## 접근 제한자 (Access Modifier)
- public : 접근 제한 없음 (같은 프로젝트 내 어디서든 사용 가능)
- protected : 해당 패키지 내, 다른 패키지에서 상속받아 자식 클래스에서 접근 가능
- default : 해당 패키지 내에서만 접근 가능
- private : 해당 클레스에서만 접근 가능

## 클래스 멤버 변수 초기화 순서
1. static 변수 선언부 : 클래스가 로드될 때 변수가 제일 먼저 초기화
2. 필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화
3. 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking (thread-safe 영역)

## Error VS Exception
- Error : 실행 중 일어날 수 있는 치명적 오류 / 컴파일 시점에 체크 X / 오류가 발생하면 프로그램 비정상 종료
- Exception : 비교적 경미한 오류 / try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있음

### CheckedException VS UncheckedException
- CheckedException : 실행 전 예측 가능한 예외 / 반드시 예외 처리 / IOException, ClassNotFoundException
- UncheckedException : 실행한 후에 알 수 있는 예외

## new String() VS 리터럴 ("")
- new String() : new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장
- "" : Heap 안에 있는 String Constant Pool 영역에 저장

## String VS StringBuffer VS StringBuilder
- String : 불변의 속성 / StringBuffer, StringBuilder : 가변의 속성
- StringBuffer : 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용
- StringBuilder : 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용

## Reference
https://dev-coco.tistory.com/153
